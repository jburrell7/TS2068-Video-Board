#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <conio.h>
#include "fpga.h"


void writeUlaReg(unsigned char reg, val);
void setWindow(unsigned char xl, yl, xr, yr);
void fillWind(unsigned char fill);
void setOp(unsigned char op);
void copyWnd(unsigned char dx, dy);

void waitForKey(void);
void copyRect(void);

void copyFromBuffer(void);
void copyToBuffer(void);
void WriteToBuffer(void);
void switchExpandedVidMode(void);

void clrScr(unsigned char color);
void placeBrick(unsigned char x, y);
void placeAllBricks(unsigned char *array);
void copyRedToBuf(void);
void placeTree(unsigned char x, y);
void copyTreeToBuf(void);
void placeShrub(unsigned char x, y);
void copyShrubToBuf(void);

// these arrays are made global to optimize access

unsigned char brick[64] = {	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18,
 							0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18,
						    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
							0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18,
							0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18,
							0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
							0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18,
 							0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18};

unsigned char brickg[64] = {0x30, 0x30, 0x30, 0x30, 0xFF, 0x30, 0x30, 0x30,
 							0x30, 0x30, 0x30, 0x30, 0xFF, 0x30, 0x30, 0x30,
						    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
							0x30, 0x30, 0x30, 0xFF, 0x30, 0x30, 0x30, 0x30,
							0x30, 0x30, 0x30, 0xFF, 0x30, 0x30, 0x30, 0x30,
							0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
							0x30, 0x30, 0x30, 0x30, 0xFF, 0x30, 0x30, 0x30,
 							0x30, 0x30, 0x30, 0x30, 0xFF, 0x30, 0x30, 0x30};


unsigned char tree[256] = {0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
                           0x01, 0x01, 0x01, 0x01, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0x01, 0x01, 0x01, 0x01,
                           0x01, 0x01, 0xe0, 0x01, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0x01, 0x01, 0x01, 0x01,
                           0x01, 0xe0, 0xe0, 0xe0, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0x01, 0x01, 0x01, 0x01,
                           0x01, 0xe0, 0xe0, 0xe0, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0x01, 0xe0, 0x01, 0x01,
                           0x01, 0xe0, 0xe0, 0xe0, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0xe0, 0xe0, 0xe0, 0x01,
                           0x01, 0x01, 0xe0, 0x01, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0xe0, 0xe0, 0xe0, 0x01,
                           0x01, 0x01, 0x94, 0x01, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0x01, 0xe0, 0x01, 0x01,
                           0x01, 0x01, 0x94, 0x94, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0x01, 0x94, 0x01, 0x01,
                           0x01, 0x01, 0x01, 0x01, 0x94, 0x01, 0xc0, 0xc0, 0xc0, 0xc0, 0x01, 0x01, 0x94, 0x94, 0x01, 0x01,
                           0x01, 0x01, 0x01, 0x01, 0x01, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x01, 0x01, 0x01, 0x01,
                           0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x94, 0x94, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
                           0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x94, 0x94, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
                           0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x94, 0x94, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
                           0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x94, 0x94, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
                           0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x94, 0x94, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01};

unsigned char shrub[64] = {	0x01, 0x01, 0xe0, 0xe0, 0xe0, 0x01, 0x01, 0x01,
                            0x01, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x01, 0x01,
                            0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x01,
                            0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x01,
                            0x01, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x01, 0x01,
                            0x01, 0x01, 0xc0, 0xc0, 0xc0, 0x01, 0x01, 0x01,
                            0x01, 0x01, 0x01, 0x94, 0x01, 0x01, 0x01, 0x01,
                            0x01, 0x01, 0x01, 0x94, 0x01, 0x01, 0x01, 0x01};


// This array specifies up to 33 groups of bricks to be placed in the main window.
//	The layout is in triplets of x and y pixel location and the length of the run
//	of bricks to lay out, l. The following applies to l:
//		l == 0		stop placing any more bricks
// for values of l != 0, the count of bricks is the lower 7 bits of l
//		l < 0x7F	place bricks horzontally
//		l > 0x81	place bricks vertically
//
//								  x		y	  l		x	  y	  	l	  x		y	  l
unsigned char brickLoc[99] = {	0x00, 0x10, 0x05, 0xD0, 0x18, 0x06, 0x18, 0x30, 0x07,
								0x48, 0x48, 0x03, 0x50, 0x50, 0x03, 0x60, 0x58, 0x09,
								0xA8, 0x88, 0x05, 0x18, 0x98, 0x06, 0x00, 0xB8, 0x20,
								0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
								0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
								0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
								0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};






void main()
{
// select hires on display B
	writeUlaReg(UR_VMODEB, MODEHR);
	writeUlaReg(UR_HRBORDER, 0x01);

	copyRedToBuf();
	copyTreeToBuf();
	copyShrubToBuf();

	clrScr(0x01);
	placeAllBricks(brickLoc);
	placeTree(0x58, 0xa8);

	placeShrub(0x20, 0xB0);
	placeShrub(0x30, 0xB0);

}

// Clear the screen with a user supplied color value
void clrScr(unsigned char color){
unsigned int i;

// ensure no logical operation is pending
	writeUlaReg(UR_HROP, HRNOP);
// set for the full screen
	setWindow(0, 0, 255, 191);
// fill it with the desired color
	fillWind(color);

	for(i = 0; i < 0xFFFF; i++);

}

// Place a tree at the pixel location given
//	by x and y. This routine assumes that
//	the tree is in buffer memory at
//	(8,0)..(23,15)
//
void placeTree(unsigned char x, y){

	setWindow(8, 0, 23, 15);
	writeUlaReg(UR_HRDESTX, x);
	writeUlaReg(UR_HRDESTY, y);
	writeUlaReg(UR_HRCMD, HRC_BTOS);
}


// Place a shrub at the pixel location given
//	by x and y. This routine assumes that
//	the tree is in buffer memory at
//	(24,0)..(31,7)
//
void placeShrub(unsigned char x, y){
	setWindow(24, 0, 31, 7);
	writeUlaReg(UR_HRDESTX, x);
	writeUlaReg(UR_HRDESTY, y);
	writeUlaReg(UR_HRCMD, HRC_BTOS);

}

// Place a brick at the pixel location
//	given by x and y. The routine assumes that
//	the bricks tile is in buffer memory at
//	(0,0)..(7,7)
//
void placeBrick(unsigned char x, y){

	setWindow(0, 0, 7, 7);
	writeUlaReg(UR_HRDESTX, x);
	writeUlaReg(UR_HRDESTY, y);
	writeUlaReg(UR_HRCMD, HRC_BTOS);

}


// Place all bricks in the bricks araay
//	at the designated location
void placeAllBricks(unsigned char *array){
unsigned char i;
unsigned char x, y, l;


// seed l for the while loop
	l = 1;
	while (l){
	// get the x coordinate
		x = *array;
		array++;
	// and the y coordinate
		y = *array;
		array++;
	// and the number of bricks to write
		l = *array;
		array++;
		if ((l & 0x7F) == 0){
			return;
		} else {
			if (l < 0x80){
				for (i = 0; i < l; i++){
					placeBrick(x, y);
					x += 8;
				}
			} else {
				l = l & 0x7F;
				for (i = 0; i < l; i++){
					placeBrick(x, y);
					y += 8;
				}
			}
		}
	}
}

void copyRedToBuf(void){
unsigned char i;

	setWindow(0, 0, 7, 7);
	outp(ULA_ADR, UR_HRBDAT);
	for (i = 0; i < 64; i++){
		outp(ULA_DAT, brick[i]);
	}
}


void copyTreeToBuf(void){
unsigned int i;

	setWindow(8, 0, 23, 15);
	outp(ULA_ADR, UR_HRBDAT);
	for (i = 0; i < 256; i++){
		outp(ULA_DAT, tree[i]);
	}
}


void copyShrubToBuf(void){
unsigned char i;

	setWindow(24, 0, 31, 7);
	outp(ULA_ADR, UR_HRBDAT);
	for (i = 0; i < 64; i++){
		outp(ULA_DAT, shrub[i]);
	}
}


void waitForKey(void){
int c;

	while (!kbhit());

}



///////////////////////////////////////////////////

void setWindow(unsigned char xl, yl, xr, yr){
	writeUlaReg(UR_HRULX, xl);
	writeUlaReg(UR_HRULY, yl);
	writeUlaReg(UR_HRLRX, xr);
	writeUlaReg(UR_HRLRY, yr);
}

void fillWind(unsigned char fill){
	writeUlaReg(UR_HRFILL, fill);
	writeUlaReg(UR_HRCMD, HRC_FILL);
}

void setOp(unsigned char op){
	writeUlaReg(UR_HROP, op);
}


void copyWnd(unsigned char dx, dy){
	writeUlaReg(UR_HRDESTX, dx);
	writeUlaReg(UR_HRDESTY, dy);
	writeUlaReg(UR_HRCMD, HRC_COPY);

}


void writeUlaReg(unsigned char reg, val){
	outp(ULA_ADR, reg);
	outp(ULA_DAT, val);
}


void copyToBuf(unsigned char dx, dy){


}

